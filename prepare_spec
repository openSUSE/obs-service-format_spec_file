#! /usr/bin/perl -w
#
# vim:sw=2:et
#

use strict;
use Data::Dumper;
use File::Basename;

our $debug        = 0;
our $base_package = "";

{

  package Section;

  sub new {
    my ($class, $name, $line) = @_;
    my $self = {name => $name, lines => [], before_lines => 0, after_lines => 0};
    push(@{$self->{lines}}, $line) if defined $line;

    bless $self, $class;
    return $self;
  }

  sub name {
    return shift->{name};
  }

  sub set_before_lines {
    my ($self, $nr) = @_;
    $self->{before_lines} = $nr;
  }


  sub set_after_lines {
    my ($self, $nr) = @_;
    $self->{after_lines} = $nr;
  }

  sub print_before_lines {
    my $self = shift;
    for (my $i = 0; $i < $self->{before_lines}; $i++) { print "\n"; }
  }

  sub print_after_lines {
    my $self = shift;
    for (my $i = 0; $i < $self->{after_lines}; $i++) { print "\n"; }
  }

  sub add_line {
    my ($self, $line) = @_;
    if ($line) {
      if ($self->{after_lines}) {
        for (my $i = 0; $i < $self->{after_lines}; $i++) { push(@{$self->{lines}}, ""); }
        $self->{after_lines} = 0;

      }
      push(@{$self->{lines}}, $line);
    }
    else {
      $self->{after_lines} += 1;
    }
  }

  sub merge_with_empty {
    my ($self, $section) = @_;
    $self->{after_lines} += scalar(@{$section->{lines}});
    return 1;
  }

  sub print {
    my $self = shift;
    if ($debug) {
      print "Section $self->{name} B:$self->{before_lines} A:$self->{after_lines}\n";
      for my $line (@{$self->{lines}}) {
        print "LINE $line\n";
      }
    }
    else {
      $self->print_before_lines();
      for my $line (@{$self->{lines}}) {
        print "$line\n";
      }
      $self->print_after_lines();
    }
  }

}

{

  package Tag;

  use base 'Section';

  sub print {
    my $self = shift;
    die "something is fishy: "
      unless $self->{before_lines} == 0 && $self->{after_lines} == 0 && length($self->{lines}) != 1;
    if ($debug) {
      printf("TAG %-16s%s\n", $self->{name} . ":", $self->value());
    }
    else {
      printf("%-16s%s\n", $self->{name} . ":", $self->value());
    }

  }

# we don't want merges
  sub merge_with_empty {
    return 0;
  }

  sub value() {
    return shift->{lines}->[0];
  }
}

{

  package Preamble;

  use base 'Section';

  sub print {
    use Time::localtime;

    my $self = shift;
    if ($debug) {
      print "PREAMBLE B:$self->{before_lines} A:$self->{after_lines}\n";
      return;
    }
    my $thisyear   = localtime->year() + 1900;
    my @copyrights = @{$self->{copyright} || []};
    unshift @copyrights, "# Copyright (c) $thisyear SUSE LLC";

    my $copy_list = join("\n", @copyrights);

    print <<EOF;
#
# spec file for package $base_package
#
$copy_list
#
# All modifications and additions to the file contributed by third parties
# remain the property of their copyright owners, unless otherwise agreed
# upon. The license for this file, and modifications and additions to the
# file, is the same license as for the pristine package itself (unless the
# license for the pristine package is not an Open Source License, in which
# case the license is the MIT License). An "Open Source License" is a
# license that conforms to the Open Source Definition (Version 1.9)
# published by the Open Source Initiative.

# Please submit bugfixes or comments via https://bugs.opensuse.org/
#
EOF
    if (defined $self->{footer}) {
      for my $footer (@{$self->{footer}}) {
        print "$footer\n";
      }
    }
    $self->print_after_lines();
  }

  sub add_copyright {
    my ($self, $copyright) = @_;
    if (!defined $self->{copyright}) {
      $self->{copyright} = [];
    }
    push(@{$self->{copyright}}, $copyright);
  }

  sub add_footer {
    my ($self, $footer) = @_;
    if (!defined $self->{footer}) {
      $self->{footer} = [];
    }
    push(@{$self->{footer}}, $footer);
  }
}

{

  package Parser;

  sub new {
    my $class = shift;
    my $self  = {'sections' => []};
    bless $self, $class;
    push(@{$self->{sections}}, Preamble->new("preamble", undef));
    return $self;
  }

  sub create_section {
    my ($self, $name, $line) = @_;
    my $section = Section->new($name, $line);
    push(@{$self->{sections}}, $section);
    return $section;
  }

  sub create_tag_section {
    my ($self, $name, $line) = @_;
    push(@{$self->{sections}}, Tag->new($name, $line));
  }

  sub create_icecream_section {
    my ($self, $line) = @_;
    $line =~ s/^#\s*icecream\s*//;
    $self->find("preamble")->add_footer("# icecream $line");
  }

  sub create_copyright_section {
    my ($self, $line) = @_;
    my $copyright = $line;
    $copyright =~ s{\s*(\d+|copyrights?|\(c\)|suse|linux|products|gmbh|nuremberg|n..?rnberg|germany|\W+)\s*}{}gi;
    if (length($copyright) <= 5) {    # not much left
      return;
    }
    $self->find("preamble")->add_copyright($line);
  }

  sub add_to_current_section {
    my ($self, $line) = @_;
    $self->current()->add_line($line);
  }

  sub current {
    return shift->{sections}->[-1];
  }

  sub current_name {
    return shift->current()->name();
  }

  sub find {
    my ($self, $name) = @_;
    for my $section (@{$self->{sections}}) {
      if ($section->name() eq $name) {
        return $section;
      }
    }
    return undef;
  }

  sub delete_section {
    my ($self, $section) = @_;
    $self->{sections} = [grep { $_ != $section } @{$self->{sections}}];
  }

  sub capitalize_case {
    my ($self, $tag) = @_;

    $tag = lc($tag);

    $tag =~ s/docdir/DocDir/i;
    $tag =~ s/arch/Arch/i;
    $tag =~ s/patch/Patch/i;
    $tag =~ s/source/Source/i;
    $tag =~ s/req/Req/i;
    $tag =~ s/confl/Confl/i;
    $tag =~ s/prov/Prov/i;
    $tag =~ s/url/URL/i;
    $tag =~ s/^(\w)/uc($1)/e;

    return $tag;
  }

  sub print_all {
    my $self = shift;

    for my $sections (@{$self->{sections}}) {
      $sections->print();
    }
  }

  sub set_current_pkg {
    my ($self, $arg) = @_;
    print "DEBUG: set_current_pkg receiving $arg\n" if $debug;
    my (@argarray) = split('\s+', $arg);
    my $curpack = $base_package;
    while (my $carg = shift @argarray) {
      next if ($carg eq "%description" || $carg eq "%package" || $carg eq "%prep");
      if ($carg eq "-l") {
        shift @argarray;
      }
      elsif ($carg eq "-n") {
        $curpack = shift @argarray;
      }
      else {
        $curpack = "$base_package-" if $base_package;
        $curpack .= $carg;
      }
    }
    print "DEBUG: set_current_pkg returning $curpack\n" if $debug;
    return $curpack;
  }

  sub read_and_parse_old_spec {
    my ($self, $specfile, $base_package) = @_;
    my $current_package = $base_package;
    my $current_lang    = "";
    my $check_printed   = "false";
    my %version;
    my $ifhandler;
    $ifhandler->{"disabled"} = 0;

    my @readspec;
    open(SPEC, '<', "$specfile") || die "can't read specfile";
    @readspec = <SPEC>;
    close SPEC;
    chomp @readspec;

    my @global_tags_list = (
      'Autoreq',       'Autoreqprov',  'BuildArch',   'BuildArchitectures',
      'BuildRequires', 'Conflicts',    'DocDir',      'Enhances',
      'Enhances',      'EssentialFor', 'ExcludeArch', 'ExclusiveArch',
      'Freshens',      'Group',        'Name',        'NoPatch',
      'NoSource',      'Obsoletes',    'Patch\d*',    'Prefix',
      'PreReq',        'Provides',     'Recommends',  'Requires',
      'Source\d*',     'Suggests',     'Summary',     'Supplements',
      'URL',           'Version',      'License',     'Release',
      'BuildConflicts'
    );

    my $global_tags_re = '^\s*(' . join("|", @global_tags_list) . ')\s*:';

    my $section_tags_re = '^\s*%(?:clean|check|prep|build|install|pre|post|preun|postun|posttrans|package|'
      . 'description|files|triggerin|triggerun|triggerpostun|verifyscript)\b';


    my $definelist;

    while (@readspec) {
      $_ = shift @readspec;

      # trim all trailing whitespace (including \r, see issue 33)
      $_ =~ s/\s+$//;

      if (/^\s*$/) {
        if ($self->current_name() eq 'empty' || $self->current_name() eq 'preamble') {
          $self->add_to_current_section("");
        }
        else {
          $self->create_section("empty", "");
        }
        next;
      }

      if (/^# vim:/ && $self->current_name() eq "preamble") {
        $self->current()->set_vim_mode($_);
        next;
      }

      if (/^#\s*needsrootforbuild\s*$/) {
        $self->find("preamble")->add_footer("# needsrootforbuild");
        next;
      }
      if (/^#\s*needsbinariesforbuild\s*$/) {
        $self->find("preamble")->add_footer("# needsbinariesforbuild");
        next;
      }
      if (/^#\s*needssslcertforbuild\s*$/) {
        $self->create_section("needssslcertforbuild", "");
        next;
      }

      if (/^#\s*norootforbuild/) {
        $self->create_section("norootforbuild", "");
        next;
      }

      if (/^#\s*nodebuginfo\s*$/) {
        $self->create_section("nodebuginfo", "");
        next;
      }

      if (/^#\s*icecream/) {
        $self->create_icecream_section($_);
        next;
      }

      if (/^#\s*Copyright\s*/ && $self->current_name() eq 'preamble') {
        $self->create_copyright_section($_);
        next;
      }

      next if (/^#\s*usedforbuild/);

      if (/^%\?__\*BuildRequires:/ || /^#!__\*BuildRequires:/) {
        $self->create_section("masked", $_);
        next;
      }

      if (/^#!BuildIgnore:/) {
        $self->create_section("buildignore", $_);
        next;
      }

      if (/^#/) {
        if ( $self->current_name() eq "description"
          || $self->current_name() eq "comment"
          || ($self->current_name() eq "preamble" && $self->current()->{after_lines} < 2))
        {
          $self->add_to_current_section($_);
        }
        else {
          $self->create_section("comment", $_);
        }
        next;
      }

      if (/^%debug_package/) {

        # remove, we add this ourselves
        next;
      }

      if (/^%define\s*vendor\s/ || /^%define\s*distribution\s/) {
        next;
      }

      if (/^\s*%if/ || /^\s*%\{/ || /^\s*%define/ || /^\s*%global/ || /^\s*%el/ || /^\s*%endif/) {
        $self->create_section("header", $_);
        if (/^\s*%if\s/) {
          my @args = split(/\s+/, $_);
          $_ =~ s/[\{\}\"]//g for (@args);
          $ifhandler->{"last_if_args"}     = join(":", @args);
          $ifhandler->{"last_if_disabled"} = 0;
          $ifhandler->{"last_if_if"}       = 1;
          $ifhandler->{"depth"}++;
          my $if_not = 0;
          if ($args[1] =~ /^\!/) {
            $args[1] =~ s/^\!//;
            $if_not = 1;
          }
          $args[2] = "" unless $args[2];
          if (
               ($args[1] eq "0")
            || ($args[1] eq "%name" && $args[2] eq "!=" && $args[3] eq $base_package)
            || ($args[1] eq "%name" && $args[2] eq "==" && $args[3] ne $base_package)
            || ($args[1] && !$args[3] && !$if_not && $definelist->{$args[1]} && $definelist->{$args[1]} eq "0")
            || ($args[2] eq "==" && $args[3] ne "0" && $definelist->{$args[1]} && $definelist->{$args[1]} eq "0")
            || ($args[2] eq "!=" && $args[3] eq "0" && $definelist->{$args[1]} && $definelist->{$args[1]} eq "0")
            || ($args[1] && !$args[3] && $if_not && $definelist->{$args[1]} && $definelist->{$args[1]} eq "1")
            || ( $args[1]
              && $args[2] eq "!="
              && $args[3] eq "1"
              && $definelist->{$args[1]}
              && $definelist->{$args[1]} eq "1")
            )
          {
            $ifhandler->{"disabled"}         = $ifhandler->{"depth"};
            $ifhandler->{"last_if_disabled"} = 1;
          }
        }
        elsif (/^\s*%if/) {
          $ifhandler->{"last_if_args"}     = "other";
          $ifhandler->{"last_if_disabled"} = 0;
          $ifhandler->{"last_if_if"}       = 0;
          $ifhandler->{"depth"}++;
        }
        elsif (/^\s*%endif/) {
          $ifhandler->{"last_if_args"} = "";
          $ifhandler->{"disabled"}     = 0 if $ifhandler->{"disabled"} == $ifhandler->{"depth"};
          $ifhandler->{"depth"}--;
        }
        elsif (/^\s*%else/) {
          $ifhandler->{"last_if_args"} .= ":else";
          if ($ifhandler->{"disabled"} == $ifhandler->{"depth"} && $ifhandler->{"last_if_disabled"} == 1) {
            $ifhandler->{"disabled"} = 0;
          }
          elsif ($ifhandler->{"disabled"} == 0 && $ifhandler->{"depth"} == 1 && $ifhandler->{"last_if_if"} == 1) {
            $ifhandler->{"disabled"} = 1;
          }
        }
        elsif (/^\s*%define\s/ || /^\s*%global\s/) {
          my @args = split(/\s+/, $_);
          $_ =~ s/[\{\}\"]//g for (@args);
          $args[2] =~ s/\Q$_\E/$definelist->{$_}/g for sort { length($b) <=> length($a) } keys(%{$definelist});
          if ($args[2] !~ /[\(\)\{\}\@\%\"\\]/) {
            $definelist->{"%" . $args[1]}         = $args[2] if $ifhandler->{"disabled"} == 0;
            $definelist->{"%{" . $args[1] . "}"}  = $args[2] if $ifhandler->{"disabled"} == 0;
            $definelist->{"%{?" . $args[1] . "}"} = $args[2] if $ifhandler->{"disabled"} == 0;
          }
          while ($_ =~ /\\$/) {
            $_ = shift @readspec;
            $self->add_to_current_section($_);
          }
        }
        next;
      }
      if (/^%package\b/i or /^%prep\b/i) {
        if (/^%package\b/i) {
          $self->create_section("header", $_);
        }
        else {
          $self->create_section("prep", $_);
        }
        $_ =~ s/^(%\w+)/lc($1)/e;
        if ($debug) {
          warn "key: $_ value: $definelist->{$_}\n" for (sort { length($b) <=> length($a) } keys(%{$definelist}));
        }
        for my $xx (sort { length($b) <=> length($a) } keys(%{$definelist})) {
          $_ =~ s/\Q$xx\E/$definelist->{$xx}/;
        }
        $_ =~ s/%\{\?[^\}]*}//;
        if ($debug) {
          warn "after: $_\n";
        }
        $current_package = $self->set_current_pkg($_);
        next;
      }
      if (/^%description\b/i) {
        $self->create_section("description", $_);
        next;
      }
      if (/^%install\b/i) {
        $self->create_section("install", $_);
        next;
      }
      if (/^%changelog\b/i) {
        $self->create_section("changelog", $_);
        next;
      }
      if (/^%/) {
        if (m/$section_tags_re/oi) {
          $_ =~ s/^(%\w+)/lc($1)/e;
          $self->create_section("section", $_);
        }
        else {
          $self->add_to_current_section($_);
        }
        next;
      }

      my $c_pack = $current_package;
      $c_pack .= "_disabled" if $ifhandler->{"disabled"};

      if (/^Vendor:/ || /^Distribution:/ || /^Packager:/) {
        next;
      }

      # remove default value of Autoreqprov
      if (/^Autoreqprov\s*:\s*(.*)/i) {
        next if (lc($1) eq "on" || lc($1) eq "yes");
      }

      if (/^Copyright\s*:\s*(.*)\s*$/i) {
        $self->create_tag_section("License", $1);
        next;
      }

      if (/^BuildArchitectures\s*:/i) {
        $_ =~ s/^[^:]+:/BuildArch:/;
      }

      if (/^BuildRoot\s*:/i) {
        $self->create_tag_section("BuildRoot", "%{_tmppath}/%{name}-%{version}-build");
        next;
      }
      if (m/^(Requires\((post|pre)\))\s*:\s*(.*)/oi) {
        $self->create_tag_section($1, $3);
        next;
      }

      if (m/$global_tags_re\s*(.*)/oi) {
        $self->create_tag_section($self->capitalize_case($1), $2);
        next;
      }

      if (m/^(Patch.*):\s*(.*)/oi || m/^(Source.*):\s*(.*)/oi) {
        $self->create_tag_section($self->capitalize_case($1), $2);
        next;
      }
      if ($self->current_name() ne 'empty' && $self->current_name() ne 'comment') {
        $self->add_to_current_section($_);
      }
      else {
        $self->create_section("line", $_);
      }
    }
  }

  sub merge_empty_sections() {
    my $self = shift;

    my $lastsection;
    for my $section (@{$self->{sections}}) {
      if ($section->name() eq 'empty') {
        if ($lastsection->merge_with_empty($section)) {
          $self->delete_section($section);
          return $self->merge_empty_sections();
        }
      }
      $lastsection = $section;
    }
  }

  # make sure two tags combined together are in proper sorting
  sub reorder_tags {
    my $self = shift;
    for my $tag (qw(BuildRequires Requires Provides Obsoletes Supplements Recommends)) {
      my $lastsection;
      for my $i (0 .. scalar(@{$self->{sections}}) - 1) {
        my $section = $self->{sections}->[$i];
        if ($section->name() eq $tag) {
          if ($lastsection) {
            if (($section->value() cmp $lastsection->value()) < 0) {
              $self->{sections}->[$i] = $lastsection;
              $self->{sections}->[$i - 1] = $section;
              return $self->reorder_tags();
            }
          }
          $lastsection = $section;
        }
        else {
          $lastsection = undef;
        }
      }
    }
  }
}

my $had_debug_package = 0;
my $ifhandler;

sub compare_arrays {
  my ($first, $second) = @_;
  return 0 unless @$first == @$second;
  for (my $i = 0; $i < @$first; $i++) {
    return 0 if $first->[$i] ne $second->[$i];
  }
  return 1;
}

my %license_replace = ();

sub load_license_map() {
  return if defined $license_replace{"GPL-2.0"};
  my $scriptdir = File::Basename::dirname($0);
  open(MAP, "$scriptdir/licenses_changes.txt") || die "can't open licenses_changes.txt";

  # ignore header
  readline(*MAP);
  my %spdx;
  while (<MAP>) {
    chomp;
    my ($license, $oldstring) = split(/\t/, $_, 2);

    #$license =~ s,\s*$,,;
    #$oldstring =~ s,\s*$,,;
    next unless length($license);

    #print STDERR "$license\t$oldstring\n";
    die "$oldstring is given twice in $_" if defined $license_replace{$oldstring};
    $license_replace{$oldstring} = $license;
    $spdx{$license}              = 1;
  }
  close(MAP);
  for (keys %spdx) {
    $license_replace{$_} = $_;
  }
}

sub replace_single_spdx($) {
  my ($l) = @_;

  return '' if $l eq '';

  load_license_map();
  $l =~ s,ORlater,or later,g;
  $l =~ s,ORsim,or similar,g;
  $l =~ s,^\s+,,;
  $l =~ s,\s+$,,;

  if (defined $license_replace{$l}) {
    $l = $license_replace{$l};
  }
  else {
    print STDERR "Unknown license '$l'\n";
  }
  return $l;
}

sub replace_spdx_and($);

sub replace_spdx_and($) {
  my ($license) = @_;

  # special case as or later is common in our spec files
  $license =~ s,or later,ORlater,g;
  $license =~ s,or similar,ORsim,g;

  #print STDERR "ORIG '$license'\n";
  my @licenses = ();
  if ($license =~ /^(.*?)\(([^)]*)\)(.*?)$/) {
    my ($head, $paren, $tail) = ($1, $2, $3);
    if ($paren =~ /AND|OR/i) {
      $head  = replace_spdx_and($head);
      $tail  = replace_spdx_and($tail);
      $paren = replace_spdx_and($paren);

      #print STDERR "AFTE '$head($paren)$tail'\n";
      return "$head($paren)$tail";
    }
  }

  for (split(/(\s+(?:AND|OR)\s+)/i, $license, -1)) {
    $_ = replace_single_spdx($_) unless $_ eq '' || /(\s+(?:AND|OR)\s+)/i;
    s/\s+/ /g;
    $_ = uc $_ if /(\s+(?:AND|OR)\s+)/i;
    push @licenses, $_;
  }

  #print STDERR "AFTE '" . join('', @licenses) . "'\n";
  return join('', @licenses);
}

sub replace_spdx($) {
  my ($license) = @_;

  my @licenses = ();
  for (split(/\s*;\s*/, $license)) {
    push @licenses, replace_spdx_and($_);
  }
  return join(' and ', @licenses);
}

if ($ARGV[0] eq '--debug') {
  $debug = 1;
  shift @ARGV;
}

my $specfile = shift(@ARGV);
if (!stat($specfile)) {
  die "$specfile is no file";
}


my @specpath = split('/', $specfile);
my $specbase = pop @specpath;
my $specdir  = join('/', @specpath);

if ($specdir eq "") {
  $specdir = ".";
}

my $xdefinelist;
my $seen_name = 0;
open(SPE, '<', "$specfile") || die("open $specfile: $!\n");
while (<SPE>) {
  chomp();
  if (/^%define/ || /^%global/) {
    my @args = split(/\s+/, $_);
    $_ =~ s/[\{\}\"]//g for (@args);
    $args[2] =~ s/\Q$_\E/$xdefinelist->{$_}/ for (sort { length($b) <=> length($a) } keys(%{$xdefinelist}));
    if ($args[2] !~ /[\(\)\{\}\@\%\"\\]/) {
      $xdefinelist->{"%" . $args[1]} = $args[2];
      $xdefinelist->{"%{" . $args[1] . "}"} = $args[2];

    }
  }
  if (/^\s*Name:/) {
    next if $seen_name;
    $seen_name    = 1;
    $base_package = $_;
    $base_package =~ s/^\s*Name:\s*(\S*)\s*/$1/;
    $base_package =~ s/\Q$_\E/$xdefinelist->{$_}/ for (sort { length($b) <=> length($a) } keys(%{$xdefinelist}));
    if ($debug) {
      warn "DEBUG: base_package = $base_package\n";
      warn Dumper($xdefinelist);

    }
    last;
  }
}
close(SPE);

warn("base_package is $base_package\n") if $debug;

if (!stat((glob("$specdir/$base_package*.spec"))[0] || "")) {
  $base_package =~ s/[0-9]$//;
}

if (!stat((glob("$specdir/$base_package*.spec"))[0] || "")) {
  $base_package =~ s/\-[^\-]*$//;
}

warn("base_package is $base_package\n") if $debug;

if (!stat((glob("$specdir/$base_package*.spec"))[0] || "")) {
  $base_package = $specbase;
  $base_package =~ s/\.spec$//;
  $base_package =~ s/\-.*$//;
}

my $parser = Parser->new;
$parser->read_and_parse_old_spec($specfile, $base_package);
$parser->merge_empty_sections();
$parser->reorder_tags();

# 2 empty lines after preamble
$parser->find("preamble")->set_after_lines(2);

# make sure we've got an empty changelog at the end
my $section = $parser->find("changelog");
$parser->delete_section($section) if $section;
my $lastsection = $parser->current();
$section = $parser->create_section("section", "%changelog");
if ($lastsection->{after_lines} == 0) {
  $section->set_before_lines(1);
}
else {
  # one is enough
  $lastsection->set_after_lines(1);
}

$parser->print_all();
